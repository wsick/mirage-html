{"version":3,"sources":["_version.ts","AnimClock.ts","Binder.ts","BinderRegistry.ts","DOMMonitor.ts","global.ts","Orchestrator.ts","PanelInserter.ts","TreeSynchronizer.ts","TreeTracker.ts"],"names":["mirage","mirage.html","mirage.html.NewAnimClock","mirage.html.NewAnimClock.tick","mirage.html.NewAnimClock.enable","mirage.html.NewAnimClock.disable","mirage.html.NewBinder","mirage.html.NewBinder.getElementSize","mirage.html.NewBinder.updateSlots","mirage.html.NewBinder.getRoot","mirage.html.NewBinder.setRoot","mirage.html.NewBinder.run","mirage.html.NewBinderRegistry","mirage.html.NewBinderRegistry.findHoistCandidate","mirage.html.NewBinderRegistry.hoist","mirage.html.NewBinderRegistry.create","mirage.html.NewBinderRegistry.adjustDestroyed","mirage.html.NewBinderRegistry.update","mirage.html.isMirageElement","mirage.html.NewDOMMonitor","mirage.html.NewDOMMonitor.start","mirage.html.NewDOMMonitor.stop","mirage.watchDOM","mirage.getRoots","mirage.getLayoutNode","mirage.dumpLayoutTree","mirage.html.NewOrchestrator","mirage.html.NewOrchestrator.onFrame","mirage.html.NewOrchestrator.start","mirage.html.NewOrchestrator.stop","mirage.html.NewPanelInserter","mirage.html.NewPanelInserter.add","mirage.html.NewPanelInserter.commit","mirage.html.NewTreeSynchronizer","mirage.html.NewTreeSynchronizer.mirrorAdded","mirage.html.NewTreeSynchronizer.mirrorUntagged","mirage.html.NewTreeSynchronizer.mirrorRemoved","mirage.html.NewTreeSynchronizer.register","mirage.html.NewTreeSynchronizer.deregister","mirage.html.NewTreeSynchronizer.promoteChildren","mirage.html.NewTreeSynchronizer.mirrorAncestry","mirage.html.NewTreeSynchronizer.configAncestors","mirage.html.NewTreeSynchronizer.update","mirage.html.NewTreeSynchronizer.init","mirage.html.NewTreeSynchronizer.scan","mirage.html.NewTreeSynchronizer.start","mirage.html.NewTreeSynchronizer.stop","mirage.html.NewTreeTracker","mirage.html.NewTreeTracker.add","mirage.html.NewTreeTracker.removeElement","mirage.html.NewTreeTracker.elementExists","mirage.html.NewTreeTracker.getNodeByElement","mirage.html.NewTreeTracker.getElementByNode","mirage.html.getNodeUid"],"mappings":"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","file":"mirage-html.min.js","sourcesContent":["module mirage.html {\r\n    export var version = '0.1.0';\r\n}\r\n","namespace mirage.html {\n    export interface IAnimClock {\n        enable();\n        disable();\n    }\n\n    export interface IAnimFrame {\n        (now: number, delta: number): void;\n    }\n\n    export function NewAnimClock(onFrame: IAnimFrame): IAnimClock {\n        let enabled = false;\n        let last = NaN;\n\n        function tick(now: number) {\n            if (!enabled)\n                return;\n            onFrame(now, isNaN(last) ? 0 : now - last);\n            last = now;\n            if (enabled)\n                window.requestAnimationFrame(tick);\n        }\n\n        return {\n            enable() {\n                enabled = true;\n                window.requestAnimationFrame(tick);\n            },\n            disable() {\n                enabled = false;\n                last = NaN;\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Binder binds a single mirage tree to a single DOM render tree.\n     Each DOM element tagged as mirage with a parent not marked as mirage will start a new binder.\n     This binding is a bidirectional communication channel.\n     - The render tree provides layout inputs and primitive measurements.\n     - The layout tree provides resulting slots (x, y, width, height) to place the absolute render elements.\n     */\n\n    export interface IBinder {\n        getRoot(): core.LayoutNode;\n        setRoot(node: core.LayoutNode);\n        run();\n    }\n\n    export function NewBinder(tree: ITreeTracker): IBinder {\n        let root: core.LayoutNode;\n        let element: Element;\n        let drafter: mirage.draft.IDrafter;\n        let lastDraftSize = new Size(NaN, NaN);\n\n        var updater: mirage.draft.IDraftUpdater = {\n            updateSlots(updates: draft.ISlotUpdate[]) {\n                for (var i = 0; i < updates.length; i++) {\n                    let update = updates[i];\n                    let el = tree.getElementByNode(update.node);\n                    // TODO: updateElement(el, update.node, update.oldRect, update.newRect);\n                }\n            },\n        };\n\n        function getElementSize(el: Element): ISize {\n            return new Size(el.scrollWidth, el.scrollHeight);\n        }\n\n        return {\n            getRoot(): core.LayoutNode {\n                return root;\n            },\n            setRoot(node: core.LayoutNode) {\n                Size.undef(lastDraftSize);\n                root = node;\n                if (!node) {\n                    element = null;\n                    drafter = null;\n                } else {\n                    element = tree.getElementByNode(root);\n                    drafter = draft.NewDrafter(root);\n                }\n            },\n            run() {\n                var rootSize = getElementSize(element);\n                if (!Size.isEqual(lastDraftSize, rootSize)) {\n                    drafter(updater, rootSize);\n                    Size.copyTo(rootSize, lastDraftSize);\n                }\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Binder Registry is intended to track all Binders.\n     This is a singleton and will track all binders.\n     Additionally, it will adjust registered binders after a structural tree change.\n     */\n\n    export interface IBinderRegistry {\n        update(addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]);\n    }\n\n    export function NewBinderRegistry(tree: ITreeTracker, binders?: IBinder[]): IBinderRegistry {\n        let roots: core.LayoutNode[] = [];\n        binders = binders || [];\n\n        // roots tracks the list of roots that are contained within binders\n        function findHoistCandidate(binder: IBinder): core.LayoutNode {\n            let curRoot = binder.getRoot();\n            if (!curRoot)\n                return null;\n            let newRoot = curRoot;\n            // walk up the tree until we find a node without a parent\n            while (newRoot.tree.parent) {\n                newRoot = newRoot.tree.parent;\n            }\n            if (newRoot === curRoot)\n                return null;\n            // if this is already being tracked by a binder, this is not a candidate\n            if (roots.indexOf(newRoot) > -1)\n                return null;\n            return newRoot;\n        }\n\n        function hoist(addedRoots: core.LayoutNode[]): core.LayoutNode[] {\n            // Hoist binders to the root\n            // This is done to ensure that a binder is the true root\n            // as a root may be slipped above an existing binder root\n            // Return added nodes that do not have binders as new root binder candidates\n            let missingBinderNodes: core.LayoutNode[] = addedRoots.slice(0);\n            for (var i = 0; i < binders.length; i++) {\n                let binder = binders[i];\n                let newRoot = findHoistCandidate(binder);\n                if (!newRoot) {\n                    // Since this binder has no candidate, let's destroy it\n                    binders.splice(i, 1);\n                    i--;\n                    continue;\n                }\n                binder.setRoot(newRoot);\n                roots.push(newRoot);\n                // If this binder matches an added root,\n                // it should be excluded from missing binder nodes\n                let missingIndex = missingBinderNodes.indexOf(newRoot);\n                if (missingIndex > -1) {\n                    missingBinderNodes.splice(missingIndex, 1);\n                }\n            }\n            return missingBinderNodes;\n        }\n\n        function create(nodes: core.LayoutNode[]) {\n            for (var i = 0; i < nodes.length; i++) {\n                let node = nodes[i];\n                let binder = NewBinder(tree);\n                binder.setRoot(node);\n                roots.push(node);\n                binders.push(binder);\n            }\n        }\n\n        function adjustDestroyed(destroyedRoots: core.LayoutNode[]) {\n            for (var i = 0; i < binders.length; i++) {\n                let binder = binders[i];\n                let curRoot = binder.getRoot();\n                let index = destroyedRoots.indexOf(curRoot);\n                if (index > -1) {\n                    // Root was destroyed, let's destroy this binder\n                    binders.splice(index, 1);\n                    i--;\n                    // Stop tracking this root as bound\n                    binder.setRoot(null);\n                    let trackIndex = roots.indexOf(curRoot);\n                    if (trackIndex > -1)\n                        roots.splice(trackIndex, 1);\n                }\n            }\n        }\n\n        return {\n            update(addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n                let missingBinderNodes = hoist(addedRoots);\n                create(missingBinderNodes);\n                adjustDestroyed(destroyedRoots);\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The DOM Monitor is intended to watch the entire DOM and filter for mirage-tagged elements.\n     It will report nodes added and removed as a result of DOM tree and attribute changes.\n     For instance, if someone deletes the `data-layout` attribute from a DOM element, it will be reported as removed.\n     */\n\n    export interface IDOMMonitor {\n        start();\n        stop();\n    }\n\n    export interface INodeMonitorUpdate {\n        (added: Element[], removed: Element[], untagged: Element[]): void;\n    }\n\n    export function isMirageElement(node: Node): boolean {\n        // Only consider element nodes\n        // Only consider nodes with 'data-layout'\n        // Attribute monitor will pick up added/removed attribute\n        return node.nodeType === node.ELEMENT_NODE\n            && !!(<Element>node).getAttribute(\"data-layout\");\n    }\n\n    export function NewDOMMonitor(target: Node, onUpdate: INodeMonitorUpdate): IDOMMonitor {\n        var observer = new MutationObserver(mutations => {\n            var added: Element[] = [];\n            var removed: Element[] = [];\n            var untagged: Element[] = [];\n\n            for (var i = 0; i < mutations.length; i++) {\n                let mutation = mutations[i];\n                if (mutation.type === \"childList\") {\n                    for (var j = 0; j < mutation.addedNodes.length; j++) {\n                        let el = mutation.addedNodes[j];\n                        if (isMirageElement(el)) {\n                            added.push(<Element>el);\n                        }\n                    }\n                    for (var j = 0; j < mutation.removedNodes.length; j++) {\n                        let el = mutation.removedNodes[j];\n                        if (isMirageElement(el)) {\n                            removed.push(<Element>el);\n                        }\n                    }\n                } else if (mutation.type === \"attributes\") {\n                    if (!mutation.oldValue) {\n                        if (isMirageElement(mutation.target)) {\n                            // 'data-layout' attribute added\n                            added.push(<Element>mutation.target);\n                        }\n                    } else {\n                        if (!isMirageElement(mutation.target)) {\n                            // 'data-layout' attribute removed\n                            untagged.push(<Element>mutation.target);\n                        }\n                    }\n                }\n            }\n\n            if (added.length > 0 || removed.length > 0 || untagged.length > 0) {\n                onUpdate(added, removed, untagged);\n            }\n        });\n\n        return {\n            start() {\n                observer.observe(target, {\n                    childList: true,\n                    subtree: true,\n                    attributes: true,\n                    attributeOldValue: true,\n                    attributeFilter: [\"data-layout\"],\n                });\n            },\n            stop() {\n                observer.disconnect();\n            },\n        };\n    }\n}","namespace mirage {\n    var orchestrator: html.IOrchestrator;\n\n    export function watchDOM(target?: Node) {\n        target = target || document.body;\n        orchestrator = html.NewOrchestrator(target);\n        orchestrator.start();\n    }\n\n    export function getRoots(): core.LayoutNode[] {\n        return orchestrator.binders.map(binder => binder.getRoot());\n    }\n\n    export function getLayoutNode(obj: Element | string): core.LayoutNode {\n        let el: Element;\n        if (typeof obj === \"string\") {\n            el = document.getElementById(obj);\n        } else {\n            el = obj;\n        }\n        return el ? orchestrator.tree.getNodeByElement(el) : null;\n    }\n\n    export function dumpLayoutTree(root: core.LayoutNode, indent?: string): string {\n        let s = \"\";\n        if (!indent) {\n            s += \"\\n\";\n            indent = \"\";\n        }\n        let ctor = root.constructor;\n        s += indent + (<any>ctor).name.toString() + \"\\n\";\n        for (let walker = root.tree.walk(); walker.step();) {\n            s += dumpLayoutTree(walker.current, indent + \"  \");\n        }\n        return s;\n    }\n}","namespace mirage.html {\n    export interface IOrchestrator {\n        tree: ITreeTracker;\n        binders: IBinder[];\n        registry: IBinderRegistry;\n        sync: ITreeSynchronizer;\n        start();\n        stop();\n    }\n\n    export function NewOrchestrator(target: Node): IOrchestrator {\n        let tree = NewTreeTracker();\n        let binders: IBinder[] = [];\n        let registry = NewBinderRegistry(tree, binders);\n        let sync = NewTreeSynchronizer(target, tree, registry);\n        let clock = NewAnimClock(onFrame);\n\n        function onFrame(now: number, delta: number) {\n            for (let i = 0; i < binders.length; i++) {\n                binders[i].run();\n            }\n        }\n\n        return {\n            tree: tree,\n            binders: binders,\n            registry: registry,\n            sync: sync,\n            start() {\n                sync.start(true);\n                clock.enable();\n            },\n            stop() {\n                clock.disable();\n                sync.stop();\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     When running tree synchronization, child nodes can appear out of order\n     The Panel Inserter will track items in escrow\n     When ready to commit, each item will be inserted into the proper index\n     */\n\n    export interface IPanelInserter {\n        add(panel: Panel, el: Element, node: core.LayoutNode);\n        commit();\n    }\n\n    interface IPanelInsertItem {\n        panel: Panel;\n        entries: IPanelInsertItemEntry[];\n    }\n    interface IPanelInsertItemEntry {\n        node: core.LayoutNode;\n        index: number;\n    }\n\n    export function NewPanelInserter(): IPanelInserter {\n        var items: IPanelInsertItem[] = [];\n\n        return {\n            add(panel: Panel, el: Element, node: core.LayoutNode) {\n                let item = panel.getAttached(\"html-sync-escrow\");\n                if (!item) {\n                    item = {\n                        panel: panel,\n                        entries: [],\n                    };\n                    panel.setAttached(\"html-sync-escrow\", item);\n                    items.push(item);\n                }\n\n                item.entries.push({\n                    node: node,\n                    index: Array.prototype.indexOf.call(el.parentElement.children, el),\n                });\n            },\n            commit() {\n                for (var i = 0; i < items.length; i++) {\n                    let item = items[i];\n                    let panel = item.panel;\n                    let entries = item.entries;\n                    panel.setAttached(\"html-sync-escrow\", undefined);\n                    entries.sort((a, b) => a.index - b.index);\n                    let inserted: core.LayoutNode[] = [];\n                    for (var j = 0; j < entries.length; j++) {\n                        let entry = entries[j];\n                        // deduplicate entries\n                        if (inserted.indexOf(entry.node) > -1)\n                            continue;\n                        inserted.push(entry.node);\n                        panel.insertChild(entry.node, entry.index);\n                    }\n                }\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Tree Synchronizer tracks added/removed DOM elements.\n     It is responsible for synchronizing the render tree with the layout tree.\n     It also detects mirage roots and builds binders.\n     */\n\n    export interface ITreeSynchronizer {\n        start(initialize: boolean);\n        stop();\n    }\n\n    export function NewTreeSynchronizer(target: Node, tree?: ITreeTracker, registry?: IBinderRegistry): ITreeSynchronizer {\n        tree = tree || NewTreeTracker();\n        registry = registry || NewBinderRegistry(tree);\n\n        function mirrorAdded(added: Element[]) {\n            // Mirror new render elements to layout tree\n            for (var i = 0; i < added.length; i++) {\n                register(added[i]);\n            }\n        }\n\n        function mirrorUntagged(untagged: Element[], addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            // Mirror nodes that have been untagged, but remain in DOM\n            for (var i = 0; i < untagged.length; i++) {\n                deregister(untagged[i], true, addedRoots, destroyedRoots);\n            }\n        }\n\n        function mirrorRemoved(removed: Element[], addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            // Mirror old render elements from layout tree\n            // Adds nodes to addedRoots that were orphaned by destroying a root\n            // Adds nodes to destroyedRoots that were destroyed mirage parents\n            for (var i = 0; i < removed.length; i++) {\n                deregister(removed[i], false, addedRoots, destroyedRoots);\n            }\n        }\n\n        function register(el: Element) {\n            if (tree.elementExists(el) || !isMirageElement(el))\n                return;\n            // The parent may not be mirrored in the layout tree yet\n            // We will set parent after all adds/removes have completed\n            // TODO: get node type\n            let node = mirage.createNodeByType(\"panel\");\n            tree.add(el, node);\n\n            // register children\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                register(cur);\n            }\n        }\n\n        function deregister(el: Element, isUntagged: boolean, addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            let node = tree.removeElement(el);\n            if (!node)\n                return;\n            if (!isUntagged) {\n                // deregister children\n                for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                    deregister(cur, true, null, null);\n                }\n            }\n\n            let parentNode = node.tree.parent;\n            if (!parentNode) {\n                destroyedRoots.push(node);\n                promoteChildren(el, addedRoots);\n            }\n\n            if (parentNode instanceof Panel) {\n                parentNode.removeChild(node);\n            } else {\n                node.setParent(null);\n            }\n        }\n\n        function promoteChildren(el: Element, addedRoots: core.LayoutNode[]) {\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                if (isMirageElement(cur)) {\n                    addedRoots.push(tree.getNodeByElement(cur));\n                } else {\n                    promoteChildren(cur, addedRoots);\n                }\n            }\n        }\n\n        function mirrorAncestry(added: Element[], addedRoots: core.LayoutNode[], inserter: IPanelInserter) {\n            // Configure parents after all layout nodes have been created/destroyed\n            // This is done to ensure parent layout nodes exist\n            // Adds nodes to addedRoots that do not have mirage parents\n            for (var i = 0; i < added.length; i++) {\n                let el = added[i];\n                let node = tree.getNodeByElement(el);\n                if (!node)\n                    continue;\n                // coerce 'none' to null\n                let parentNode = (el.parentElement ? tree.getNodeByElement(el.parentElement) : null) || null;\n                if (parentNode instanceof Panel) {\n                    // To ensure proper ordering, we will collect all new children for each parent\n                    // We will insert the children in sorted order\n                    inserter.add(parentNode, el, node);\n                } else {\n                    node.setParent(parentNode);\n                }\n                if (!node.tree.parent) {\n                    addedRoots.push(node);\n                }\n                configAncestors(el, node, inserter);\n            }\n        }\n\n        function configAncestors(parentEl: Element, parentNode: core.LayoutNode, inserter: IPanelInserter) {\n            for (let cur = parentEl.firstElementChild, i = 0; !!cur; cur = cur.nextElementSibling, i++) {\n                let curNode = tree.getNodeByElement(cur);\n                if (curNode && !curNode.tree.parent) {\n                    if (parentNode instanceof Panel) {\n                        inserter.add(parentNode, cur, curNode);\n                    } else {\n                        curNode.setParent(parentNode);\n                    }\n                    configAncestors(cur, curNode, inserter);\n                }\n            }\n        }\n\n        /*\n         Each update, we need to\n         - construct new layout nodes mirroring new render elements\n         - detach layout nodes mirroring old render elements\n         - configure all new layout nodes with parent\n         - hoist binders to the true root\n         - add binders for new root nodes\n         */\n        function update(added: Element[], removed: Element[], untagged: Element[]) {\n            let inserter = NewPanelInserter();\n            let addedRoots: core.LayoutNode[] = [];\n            let destroyedRoots: core.LayoutNode[] = [];\n\n            mirrorAdded(added);\n            mirrorUntagged(untagged, addedRoots, destroyedRoots);\n            mirrorRemoved(removed, addedRoots, destroyedRoots);\n            mirrorAncestry(added, addedRoots, inserter);\n\n            inserter.commit();\n            registry.update(addedRoots, destroyedRoots);\n        }\n\n        function init() {\n            let added: Element[] = [];\n            scan(<Element>target, added, false);\n            update(added, [], []);\n        }\n\n        function scan(el: Element, added: Element[], parentIsMirage: boolean) {\n            let isMirage = isMirageElement(el);\n            if (isMirage && !parentIsMirage)\n                added.push(el);\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                scan(cur, added, isMirage);\n            }\n        }\n\n        var monitor = NewDOMMonitor(target, update);\n        return {\n            start(initialize: boolean) {\n                if (initialize)\n                    init();\n                monitor.start();\n            },\n            stop() {\n                monitor.stop();\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Tree Tracker tracks render elements (DOM) and layout nodes (mirage).\n     This is a singleton and tracks the entire DOM.\n     Instead of doing lookups using a synchronized double-array, we are tracking a uid on each object.\n     The render element and layout node can be retrieved by uid.\n     We use a DOM attribute ('http://schemas.wsick.com/mirage/html':uid)\n     and a layout node attached property ('mirage-uid') to track the uid.\n     This uid is a running int counter that is converted to a string to match attributes.\n     */\n\n    var XMLNS = \"http://schemas.wsick.com/mirage/html\";\n\n    export interface ITreeTracker {\n        add(el: Element, node: core.LayoutNode): string;\n        removeElement(el: Element);\n        elementExists(el: Element): boolean;\n        getNodeByElement(el: Element): core.LayoutNode;\n        getElementByNode(node: core.LayoutNode): Element;\n    }\n\n    interface IElementHash {\n        [uid: string]: Element;\n    }\n    interface ILayoutNodeHash {\n        [uid: string]: core.LayoutNode;\n    }\n\n    export function NewTreeTracker(): ITreeTracker {\n        var elements: IElementHash = {};\n        var nodes: ILayoutNodeHash = {};\n        var lastUid = 0;\n\n        return {\n            add(el: Element, node: core.LayoutNode): string {\n                lastUid++;\n                var uid = lastUid.toString();\n                el.setAttributeNS(XMLNS, \"uid\", uid);\n                node.setAttached(\"mirage-uid\", uid);\n                elements[uid] = el;\n                nodes[uid] = node;\n                return uid;\n            },\n            removeElement(el: Element): core.LayoutNode {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                var node = !uid ? null : nodes[uid];\n                el.removeAttributeNS(XMLNS, \"uid\");\n                if (node) {\n                    node.setAttached(\"mirage-uid\", undefined);\n                    delete elements[uid];\n                    delete nodes[uid];\n                }\n                return node;\n            },\n            elementExists(el: Element): boolean {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                return elements[uid] === el;\n            },\n            getNodeByElement(el: Element): core.LayoutNode {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                return nodes[uid];\n            },\n            getElementByNode(node: core.LayoutNode): Element {\n                var uid = node.getAttached(\"mirage-uid\");\n                return elements[uid];\n            },\n        };\n    }\n\n    export function getNodeUid(node: core.LayoutNode): string {\n        return node.getAttached(\"mirage-uid\");\n    }\n}"],"sourceRoot":"/mirage"}