{"version":3,"sources":["_version.ts","AnimClock.ts","Binder.ts","BinderRegistry.ts","DOMMonitor.ts","DraftUpdater.ts","ElementTranslator.ts","global.ts","mirage-html.plugin.js","HtmlNode.ts","Orchestrator.ts","PanelInserter.ts","TreeSynchronizer.ts","TreeTracker.ts"],"names":["mirage","mirage.html","mirage.html.NewAnimClock","mirage.html.NewAnimClock.tick","mirage.html.NewAnimClock.enable","mirage.html.NewAnimClock.disable","mirage.html.NewBinder","mirage.html.NewBinder.getRootSize","mirage.html.NewBinder.getRoot","mirage.html.NewBinder.setRoot","mirage.html.NewBinder.run","mirage.html.NewBinderRegistry","mirage.html.NewBinderRegistry.hoist","mirage.html.NewBinderRegistry.findRoot","mirage.html.NewBinderRegistry.replaceBinderRoot","mirage.html.NewBinderRegistry.create","mirage.html.NewBinderRegistry.destroy","mirage.html.NewBinderRegistry.destroyBinder","mirage.html.NewBinderRegistry.update","mirage.html.isMirageElement","mirage.html.NewDOMMonitor","mirage.html.NewDOMMonitor.start","mirage.html.NewDOMMonitor.stop","mirage.html.NewDraftUpdater","mirage.html.NewDraftUpdater.updateSlot","mirage.html.NewDraftUpdater.updateSlots","mirage.html.NewElementTranslator","mirage.html.NewElementTranslator.parseDataLayout","mirage.html.NewElementTranslator.applyHash","mirage.html.NewElementTranslator.translateNew","mirage.html.NewElementTranslator.translateChange","mirage.html.watch","mirage.html.getRoots","mirage.html.getLayoutNode","mirage.html.dumpLayoutTree","mirage.html.enableLogging","__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","mirage.html.calcElementDesired","mirage.html.HtmlNode","mirage.html.HtmlNode.constructor","mirage.html.HtmlNode.getElement","mirage.html.HtmlNode.setElement","mirage.html.HtmlNode.measureOverride","mirage.html.HtmlNode.arrangeOverride","mirage.html.HtmlNode.isDummyElement","mirage.html.NewOrchestrator","mirage.html.NewOrchestrator.onFrame","mirage.html.NewOrchestrator.start","mirage.html.NewOrchestrator.stop","mirage.html.NewPanelInserter","mirage.html.NewPanelInserter.add","mirage.html.NewPanelInserter.commit","mirage.html.NewTreeSynchronizer","mirage.html.NewTreeSynchronizer.mirrorAdded","mirage.html.NewTreeSynchronizer.mirrorUntagged","mirage.html.NewTreeSynchronizer.mirrorRemoved","mirage.html.NewTreeSynchronizer.register","mirage.html.NewTreeSynchronizer.deregister","mirage.html.NewTreeSynchronizer.promoteChildren","mirage.html.NewTreeSynchronizer.mirrorTranslations","mirage.html.NewTreeSynchronizer.replaceNode","mirage.html.NewTreeSynchronizer.mirrorAncestry","mirage.html.NewTreeSynchronizer.configAncestors","mirage.html.NewTreeSynchronizer.update","mirage.html.NewTreeSynchronizer.init","mirage.html.NewTreeSynchronizer.scan","mirage.html.NewTreeSynchronizer.start","mirage.html.NewTreeSynchronizer.stop","mirage.html.NewTreeTracker","mirage.html.NewTreeTracker.add","mirage.html.NewTreeTracker.replaceNode","mirage.html.NewTreeTracker.removeElement","mirage.html.NewTreeTracker.elementExists","mirage.html.NewTreeTracker.getNodeByElement","mirage.html.NewTreeTracker.getElementByNode","mirage.html.getNodeUid"],"mappings":"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","file":"mirage-html.plugin.min.js","sourcesContent":["module mirage.html {\r\n    export var version = '0.1.1';\r\n}","namespace mirage.html {\n    export interface IAnimClock {\n        enable();\n        disable();\n    }\n\n    export interface IAnimFrame {\n        (now: number, delta: number): void;\n    }\n\n    export function NewAnimClock(onFrame: IAnimFrame): IAnimClock {\n        let enabled = false;\n        let last = NaN;\n\n        function tick(now: number) {\n            if (!enabled)\n                return;\n            onFrame(now, isNaN(last) ? 0 : now - last);\n            last = now;\n            if (enabled)\n                window.requestAnimationFrame(tick);\n        }\n\n        return {\n            enable() {\n                enabled = true;\n                window.requestAnimationFrame(tick);\n            },\n            disable() {\n                enabled = false;\n                last = NaN;\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Binder binds a single mirage tree to a single DOM render tree.\n     Each DOM element tagged as mirage with a parent not marked as mirage will start a new binder.\n     This binding is a bidirectional communication channel.\n     - The render tree provides layout inputs and primitive measurements.\n     - The layout tree provides resulting slots (x, y, width, height) to place the absolute render elements.\n     */\n\n    export interface IBinder {\n        getRoot(): core.LayoutNode;\n        setRoot(node: core.LayoutNode);\n        run();\n    }\n\n    export function NewBinder(tree: ITreeTracker): IBinder {\n        let root: core.LayoutNode;\n        let element: HTMLElement;\n        let drafter: mirage.draft.IDrafter;\n        let updater: mirage.draft.IDraftUpdater = NewDraftUpdater(tree);\n        let lastDraftSize = new Size(NaN, NaN);\n\n        function getRootSize(): ISize {\n            let htmlHeight = root.getAttached(\"html.height\");\n            if (htmlHeight === \"window\")\n                return new Size(window.innerWidth, window.innerHeight - 20);\n            if (htmlHeight === \"infinite\")\n                return new Size(window.innerWidth, Number.POSITIVE_INFINITY);\n            return new Size(element.scrollWidth, element.scrollHeight);\n        }\n\n        return {\n            getRoot(): core.LayoutNode {\n                return root;\n            },\n            setRoot(node: core.LayoutNode) {\n                Size.undef(lastDraftSize);\n                root = node;\n                if (!node) {\n                    element = null;\n                    drafter = null;\n                } else {\n                    element = <HTMLElement>tree.getElementByNode(root);\n                    drafter = draft.NewDrafter(root);\n                }\n            },\n            run() {\n                let rootSize = getRootSize();\n                if (!Size.isEqual(lastDraftSize, rootSize)) {\n                    root.invalidateMeasure();\n                    Size.copyTo(rootSize, lastDraftSize);\n                }\n                if ((root.state.flags & mirage.core.LayoutFlags.hints) > 0) {\n                    drafter(updater, rootSize);\n                }\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Binder Registry is intended to track all Binders.\n     This is a singleton and will track all binders.\n     Additionally, it will adjust registered binders after a structural tree change.\n     */\n\n    export interface IBinderRegistry {\n        update(addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]);\n    }\n\n    export function NewBinderRegistry(tree: ITreeTracker, binders?: IBinder[]): IBinderRegistry {\n        let roots: core.LayoutNode[] = [];\n        binders = binders || [];\n\n        function hoist(addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            // Hoist binders to the root\n            // This is done to ensure that a binder is the true root\n            // as a root may be slipped above an existing binder root\n            // Added roots will be stripped of hoisted roots from existing binders\n            for (var i = 0; i < binders.length; i++) {\n                let binder = binders[i];\n                let curRoot = binder.getRoot();\n                if (!curRoot) {\n                    // Dead binder, destroy it\n                    binders.splice(i, 1);\n                    i--;\n                    continue;\n                }\n                let newRoot = findRoot(curRoot);\n                if (curRoot !== newRoot) {\n                    replaceBinderRoot(binder, curRoot, newRoot, destroyedRoots);\n                }\n\n                // If this binder was taken over by newRoot and exists in addedRoots,\n                // we should remove so a duplicate binder isn't created\n                let existingIndex = addedRoots.indexOf(newRoot);\n                if (existingIndex > -1)\n                    addedRoots.splice(i, 1);\n            }\n        }\n\n        function findRoot(curRoot: core.LayoutNode): core.LayoutNode {\n            let newRoot = curRoot;\n            while (newRoot.tree.parent) {\n                newRoot = newRoot.tree.parent;\n            }\n            return newRoot;\n        }\n\n        function replaceBinderRoot(binder: IBinder, curRoot: core.LayoutNode, newRoot: core.LayoutNode, destroyedRoots: core.LayoutNode[]) {\n            // Replace this binder's root with newRoot\n\n            // If newRoot already has a binder, this binder should be destroyed\n            if (roots.indexOf(newRoot) > -1) {\n                destroyedRoots.push(curRoot);\n                return;\n            }\n\n            // stop tracking current root\n            let oldIndex = roots.indexOf(curRoot);\n            if (oldIndex > -1)\n                roots.splice(oldIndex, 1);\n\n            binder.setRoot(newRoot);\n            roots.push(newRoot);\n        }\n\n        function create(nodes: core.LayoutNode[]) {\n            for (var i = 0; i < nodes.length; i++) {\n                let node = nodes[i];\n                let binder = NewBinder(tree);\n                binder.setRoot(node);\n                roots.push(node);\n                binders.push(binder);\n            }\n        }\n\n        function destroy(destroyedRoots: core.LayoutNode[]) {\n            for (var i = 0; i < binders.length; i++) {\n                let index = destroyedRoots.indexOf(binders[i].getRoot());\n                if (index > -1) {\n                    destroyBinder(i);\n                    i--;\n                }\n            }\n        }\n\n        function destroyBinder(index: number) {\n            let binder = binders.splice(index, 1)[0];\n            let curRoot = binder.getRoot();\n            binder.setRoot(null);\n            if (curRoot) {\n                // Stop tracking this root as bound\n                let trackIndex = roots.indexOf(curRoot);\n                if (trackIndex > -1)\n                    roots.splice(trackIndex, 1);\n            }\n        }\n\n        return {\n            update(addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n                hoist(addedRoots, destroyedRoots);\n                create(addedRoots);\n                destroy(destroyedRoots);\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The DOM Monitor is intended to watch the entire DOM and filter for mirage-tagged elements.\n     It will report nodes added and removed as a result of DOM tree and attribute changes.\n     For instance, if someone deletes the `data-layout` attribute from a DOM element, it will be reported as removed.\n     */\n\n    export interface IDOMMonitor {\n        start();\n        stop();\n    }\n\n    export interface INodeMonitorUpdate {\n        (added: Element[], removed: Element[], untagged: Element[], changed: IDataLayoutChange[]): void;\n    }\n\n    export interface IDataLayoutChange {\n        target: Element;\n        oldValue: string;\n    }\n\n    export function isMirageElement(node: Node): boolean {\n        // Only consider element nodes\n        // Only consider nodes with 'data-layout'\n        // Attribute monitor will pick up added/removed attribute\n        return node.nodeType === node.ELEMENT_NODE\n            && !!(<Element>node).getAttribute(\"data-layout\");\n    }\n\n    export function NewDOMMonitor(target: Node, onUpdate: INodeMonitorUpdate): IDOMMonitor {\n        var observer = new MutationObserver(mutations => {\n            var added: Element[] = [];\n            var removed: Element[] = [];\n            var untagged: Element[] = [];\n            var changed: IDataLayoutChange[] = [];\n\n            let needsUpdate = false;\n            for (var i = 0; i < mutations.length; i++) {\n                let mutation = mutations[i];\n                if (HtmlNode.isDummyElement(mutation.target))\n                    continue;\n                if (mutation.type === \"childList\") {\n                    for (var j = 0; j < mutation.addedNodes.length; j++) {\n                        let el = mutation.addedNodes[j];\n                        if (isMirageElement(el)) {\n                            added.push(<Element>el);\n                            needsUpdate = true;\n                        }\n                    }\n                    for (var j = 0; j < mutation.removedNodes.length; j++) {\n                        let el = mutation.removedNodes[j];\n                        if (isMirageElement(el)) {\n                            removed.push(<Element>el);\n                            needsUpdate = true;\n                        }\n                    }\n                } else if (mutation.type === \"attributes\") {\n                    if (!mutation.oldValue) {\n                        if (isMirageElement(mutation.target)) {\n                            // 'data-layout' attribute added\n                            added.push(<Element>mutation.target);\n                            needsUpdate = true;\n                        }\n                    } else {\n                        if (!isMirageElement(mutation.target)) {\n                            // 'data-layout' attribute removed\n                            untagged.push(<Element>mutation.target);\n                            needsUpdate = true;\n                        } else {\n                            // 'data-layout' attribute changed\n                            changed.push({target: <Element>mutation.target, oldValue: mutation.oldValue});\n                            needsUpdate = true;\n                        }\n                    }\n                }\n            }\n\n            if (needsUpdate) {\n                onUpdate(added, removed, untagged, changed);\n            }\n        });\n\n        return {\n            start() {\n                observer.observe(target, {\n                    childList: true,\n                    subtree: true,\n                    attributes: true,\n                    attributeOldValue: true,\n                    attributeFilter: [\"data-layout\"],\n                });\n            },\n            stop() {\n                observer.disconnect();\n            },\n        };\n    }\n}","namespace mirage.html {\n    export function NewDraftUpdater(tree: ITreeTracker): mirage.draft.IDraftUpdater {\n        function updateSlot(el: HTMLElement, slot: IRect) {\n            el.style.position = \"absolute\";\n            el.style.left = `${slot.x}px`;\n            el.style.top = `${slot.y}px`;\n            el.style.width = `${slot.width}px`;\n            el.style.height = `${slot.height}px`;\n            el.style.boxSizing = \"border-box\";\n        }\n\n        return {\n            updateSlots(updates: draft.ISlotUpdate[]) {\n                for (var i = 0; i < updates.length; i++) {\n                    let update = updates[i];\n                    let node = update.node;\n\n                    let el = <HTMLElement>tree.getElementByNode(update.node);\n                    el.style.display = \"none\";\n                    if (node.tree.parent)\n                        updateSlot(<HTMLElement>tree.getElementByNode(update.node), update.newRect);\n                    el.style.display = \"\";\n                }\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Element Translator translates the data-layout attribute into a layout node\n     If it is detected that \"type\" changed during a data-layout change,\n     a new filled layout node will be returned, but not replaced in the layout tree\n     During any translation, if null is returned, the node should be destroyed\n     */\n\n    export interface IElementTranslator {\n        translateNew(el: Element): core.LayoutNode;\n        translateChange(el: Element, node: core.LayoutNode, oldDataLayout: string): core.LayoutNode;\n    }\n    interface IDataLayoutHash {\n        [property: string]: string;\n    }\n    export function NewElementTranslator(): IElementTranslator {\n        function parseDataLayout(dataLayout: string): IDataLayoutHash {\n            let hash: IDataLayoutHash = {};\n            for (let tokens = dataLayout.split(\";\"), i = 0; i < tokens.length; i++) {\n                let token = tokens[i];\n                let index = token.indexOf(':');\n                if (index < 0)\n                    continue;\n                hash[token.substr(0, index).trim()] = token.substr(index + 1).trim();\n            }\n            return hash;\n        }\n\n        function applyHash(node: core.LayoutNode, hash: IDataLayoutHash) {\n            for (let keys = Object.keys(hash), i = 0; i < keys.length; i++) {\n                let key = keys[i];\n                let mapper = mirage.map.getMapper(key);\n                if (mapper)\n                    mapper(node, hash[key]);\n            }\n        }\n\n        return {\n            translateNew(el: Element): core.LayoutNode {\n                let hash = parseDataLayout(el.getAttribute(\"data-layout\"));\n                let type = hash[\"type\"];\n                if (!type)\n                    return null;\n                let node = mirage.createNodeByType(type);\n                if (type === \"html\")\n                    HtmlNode.setElement(node, <HTMLElement>el);\n                applyHash(node, hash);\n                return node;\n            },\n            translateChange(el: Element, node: core.LayoutNode, oldDataLayout: string): core.LayoutNode {\n                let oldHash = parseDataLayout(oldDataLayout);\n                let newHash = parseDataLayout(el.getAttribute(\"data-layout\"));\n                let newType = newHash[\"type\"];\n                if (!newType)\n                    return null;\n                if (oldHash[\"type\"] !== newType) {\n                    let newNode = mirage.createNodeByType(newType);\n                    applyHash(newNode, newHash);\n                    return newNode;\n                }\n\n                // Unset values that exist in old, but not in new\n                let oldKeys = Object.keys(oldHash);\n                let newKeys = Object.keys(newHash);\n                for (let i = 0; i < oldKeys.length; i++) {\n                    let key = oldKeys[i];\n                    if (newKeys.indexOf(key) > -1)\n                        continue;\n                    let mapper = mirage.map.getMapper(key);\n                    if (mapper)\n                        mapper(node, undefined);\n                }\n\n                applyHash(node, newHash);\n                return node;\n            },\n        };\n    }\n}","namespace mirage.html {\n    var orchestrator: html.IOrchestrator;\n\n    export function watch(target?: Node) {\n        target = target || document.body;\n        orchestrator = html.NewOrchestrator(target);\n        orchestrator.start();\n    }\n\n    export function getRoots(): core.LayoutNode[] {\n        return orchestrator.binders.map(binder => binder.getRoot());\n    }\n\n    export function getLayoutNode(obj: Element | string): core.LayoutNode {\n        let el: Element;\n        if (typeof obj === \"string\") {\n            el = document.getElementById(obj);\n        } else {\n            el = obj;\n        }\n        return el ? orchestrator.tree.getNodeByElement(el) : null;\n    }\n\n    export function dumpLayoutTree(root: core.LayoutNode, indent?: string): string {\n        let s = \"\";\n        if (!indent) {\n            s += \"\\n\";\n            indent = \"\";\n        }\n        let ctor = root.constructor;\n        s += indent + (<any>ctor).name.toString() + \"\\n\";\n        for (let walker = root.tree.walk(); walker.step();) {\n            s += dumpLayoutTree(walker.current, indent + \"  \");\n        }\n        return s;\n    }\n\n    export function enableLogging() {\n        mirage.logger = mirage.logging.NewConsoleLogger(node => {\n            let el = orchestrator.tree.getElementByNode(node);\n            let id = el && el.id ? `#${el.id}` : \"\";\n            let type = <any>node.constructor;\n            return `${type.name}${id}`;\n        });\n    }\n}","var mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        html.version = '0.1.1';\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewAnimClock(onFrame) {\n            var enabled = false;\n            var last = NaN;\n            function tick(now) {\n                if (!enabled)\n                    return;\n                onFrame(now, isNaN(last) ? 0 : now - last);\n                last = now;\n                if (enabled)\n                    window.requestAnimationFrame(tick);\n            }\n            return {\n                enable: function () {\n                    enabled = true;\n                    window.requestAnimationFrame(tick);\n                },\n                disable: function () {\n                    enabled = false;\n                    last = NaN;\n                },\n            };\n        }\n        html.NewAnimClock = NewAnimClock;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewBinder(tree) {\n            var root;\n            var element;\n            var drafter;\n            var updater = html.NewDraftUpdater(tree);\n            var lastDraftSize = new mirage.Size(NaN, NaN);\n            function getRootSize() {\n                var htmlHeight = root.getAttached(\"html.height\");\n                if (htmlHeight === \"window\")\n                    return new mirage.Size(window.innerWidth, window.innerHeight - 20);\n                if (htmlHeight === \"infinite\")\n                    return new mirage.Size(window.innerWidth, Number.POSITIVE_INFINITY);\n                return new mirage.Size(element.scrollWidth, element.scrollHeight);\n            }\n            return {\n                getRoot: function () {\n                    return root;\n                },\n                setRoot: function (node) {\n                    mirage.Size.undef(lastDraftSize);\n                    root = node;\n                    if (!node) {\n                        element = null;\n                        drafter = null;\n                    }\n                    else {\n                        element = tree.getElementByNode(root);\n                        drafter = mirage.draft.NewDrafter(root);\n                    }\n                },\n                run: function () {\n                    var rootSize = getRootSize();\n                    if (!mirage.Size.isEqual(lastDraftSize, rootSize)) {\n                        root.invalidateMeasure();\n                        mirage.Size.copyTo(rootSize, lastDraftSize);\n                    }\n                    if ((root.state.flags & mirage.core.LayoutFlags.hints) > 0) {\n                        drafter(updater, rootSize);\n                    }\n                },\n            };\n        }\n        html.NewBinder = NewBinder;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewBinderRegistry(tree, binders) {\n            var roots = [];\n            binders = binders || [];\n            function hoist(addedRoots, destroyedRoots) {\n                for (var i = 0; i < binders.length; i++) {\n                    var binder = binders[i];\n                    var curRoot = binder.getRoot();\n                    if (!curRoot) {\n                        binders.splice(i, 1);\n                        i--;\n                        continue;\n                    }\n                    var newRoot = findRoot(curRoot);\n                    if (curRoot !== newRoot) {\n                        replaceBinderRoot(binder, curRoot, newRoot, destroyedRoots);\n                    }\n                    var existingIndex = addedRoots.indexOf(newRoot);\n                    if (existingIndex > -1)\n                        addedRoots.splice(i, 1);\n                }\n            }\n            function findRoot(curRoot) {\n                var newRoot = curRoot;\n                while (newRoot.tree.parent) {\n                    newRoot = newRoot.tree.parent;\n                }\n                return newRoot;\n            }\n            function replaceBinderRoot(binder, curRoot, newRoot, destroyedRoots) {\n                // Replace this binder's root with newRoot\n                if (roots.indexOf(newRoot) > -1) {\n                    destroyedRoots.push(curRoot);\n                    return;\n                }\n                var oldIndex = roots.indexOf(curRoot);\n                if (oldIndex > -1)\n                    roots.splice(oldIndex, 1);\n                binder.setRoot(newRoot);\n                roots.push(newRoot);\n            }\n            function create(nodes) {\n                for (var i = 0; i < nodes.length; i++) {\n                    var node = nodes[i];\n                    var binder = html.NewBinder(tree);\n                    binder.setRoot(node);\n                    roots.push(node);\n                    binders.push(binder);\n                }\n            }\n            function destroy(destroyedRoots) {\n                for (var i = 0; i < binders.length; i++) {\n                    var index = destroyedRoots.indexOf(binders[i].getRoot());\n                    if (index > -1) {\n                        destroyBinder(i);\n                        i--;\n                    }\n                }\n            }\n            function destroyBinder(index) {\n                var binder = binders.splice(index, 1)[0];\n                var curRoot = binder.getRoot();\n                binder.setRoot(null);\n                if (curRoot) {\n                    var trackIndex = roots.indexOf(curRoot);\n                    if (trackIndex > -1)\n                        roots.splice(trackIndex, 1);\n                }\n            }\n            return {\n                update: function (addedRoots, destroyedRoots) {\n                    hoist(addedRoots, destroyedRoots);\n                    create(addedRoots);\n                    destroy(destroyedRoots);\n                },\n            };\n        }\n        html.NewBinderRegistry = NewBinderRegistry;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function isMirageElement(node) {\n            return node.nodeType === node.ELEMENT_NODE\n                && !!node.getAttribute(\"data-layout\");\n        }\n        html.isMirageElement = isMirageElement;\n        function NewDOMMonitor(target, onUpdate) {\n            var observer = new MutationObserver(function (mutations) {\n                var added = [];\n                var removed = [];\n                var untagged = [];\n                var changed = [];\n                var needsUpdate = false;\n                for (var i = 0; i < mutations.length; i++) {\n                    var mutation = mutations[i];\n                    if (html.HtmlNode.isDummyElement(mutation.target))\n                        continue;\n                    if (mutation.type === \"childList\") {\n                        for (var j = 0; j < mutation.addedNodes.length; j++) {\n                            var el = mutation.addedNodes[j];\n                            if (isMirageElement(el)) {\n                                added.push(el);\n                                needsUpdate = true;\n                            }\n                        }\n                        for (var j = 0; j < mutation.removedNodes.length; j++) {\n                            var el = mutation.removedNodes[j];\n                            if (isMirageElement(el)) {\n                                removed.push(el);\n                                needsUpdate = true;\n                            }\n                        }\n                    }\n                    else if (mutation.type === \"attributes\") {\n                        if (!mutation.oldValue) {\n                            if (isMirageElement(mutation.target)) {\n                                added.push(mutation.target);\n                                needsUpdate = true;\n                            }\n                        }\n                        else {\n                            if (!isMirageElement(mutation.target)) {\n                                untagged.push(mutation.target);\n                                needsUpdate = true;\n                            }\n                            else {\n                                changed.push({ target: mutation.target, oldValue: mutation.oldValue });\n                                needsUpdate = true;\n                            }\n                        }\n                    }\n                }\n                if (needsUpdate) {\n                    onUpdate(added, removed, untagged, changed);\n                }\n            });\n            return {\n                start: function () {\n                    observer.observe(target, {\n                        childList: true,\n                        subtree: true,\n                        attributes: true,\n                        attributeOldValue: true,\n                        attributeFilter: [\"data-layout\"],\n                    });\n                },\n                stop: function () {\n                    observer.disconnect();\n                },\n            };\n        }\n        html.NewDOMMonitor = NewDOMMonitor;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewDraftUpdater(tree) {\n            function updateSlot(el, slot) {\n                el.style.position = \"absolute\";\n                el.style.left = slot.x + \"px\";\n                el.style.top = slot.y + \"px\";\n                el.style.width = slot.width + \"px\";\n                el.style.height = slot.height + \"px\";\n                el.style.boxSizing = \"border-box\";\n            }\n            return {\n                updateSlots: function (updates) {\n                    for (var i = 0; i < updates.length; i++) {\n                        var update = updates[i];\n                        var node = update.node;\n                        var el = tree.getElementByNode(update.node);\n                        el.style.display = \"none\";\n                        if (node.tree.parent)\n                            updateSlot(tree.getElementByNode(update.node), update.newRect);\n                        el.style.display = \"\";\n                    }\n                },\n            };\n        }\n        html.NewDraftUpdater = NewDraftUpdater;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewElementTranslator() {\n            function parseDataLayout(dataLayout) {\n                var hash = {};\n                for (var tokens = dataLayout.split(\";\"), i = 0; i < tokens.length; i++) {\n                    var token = tokens[i];\n                    var index = token.indexOf(':');\n                    if (index < 0)\n                        continue;\n                    hash[token.substr(0, index).trim()] = token.substr(index + 1).trim();\n                }\n                return hash;\n            }\n            function applyHash(node, hash) {\n                for (var keys = Object.keys(hash), i = 0; i < keys.length; i++) {\n                    var key = keys[i];\n                    var mapper = mirage.map.getMapper(key);\n                    if (mapper)\n                        mapper(node, hash[key]);\n                }\n            }\n            return {\n                translateNew: function (el) {\n                    var hash = parseDataLayout(el.getAttribute(\"data-layout\"));\n                    var type = hash[\"type\"];\n                    if (!type)\n                        return null;\n                    var node = mirage.createNodeByType(type);\n                    if (type === \"html\")\n                        html.HtmlNode.setElement(node, el);\n                    applyHash(node, hash);\n                    return node;\n                },\n                translateChange: function (el, node, oldDataLayout) {\n                    var oldHash = parseDataLayout(oldDataLayout);\n                    var newHash = parseDataLayout(el.getAttribute(\"data-layout\"));\n                    var newType = newHash[\"type\"];\n                    if (!newType)\n                        return null;\n                    if (oldHash[\"type\"] !== newType) {\n                        var newNode = mirage.createNodeByType(newType);\n                        applyHash(newNode, newHash);\n                        return newNode;\n                    }\n                    var oldKeys = Object.keys(oldHash);\n                    var newKeys = Object.keys(newHash);\n                    for (var i = 0; i < oldKeys.length; i++) {\n                        var key = oldKeys[i];\n                        if (newKeys.indexOf(key) > -1)\n                            continue;\n                        var mapper = mirage.map.getMapper(key);\n                        if (mapper)\n                            mapper(node, undefined);\n                    }\n                    applyHash(node, newHash);\n                    return node;\n                },\n            };\n        }\n        html.NewElementTranslator = NewElementTranslator;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        var orchestrator;\n        function watch(target) {\n            target = target || document.body;\n            orchestrator = html.NewOrchestrator(target);\n            orchestrator.start();\n        }\n        html.watch = watch;\n        function getRoots() {\n            return orchestrator.binders.map(function (binder) { return binder.getRoot(); });\n        }\n        html.getRoots = getRoots;\n        function getLayoutNode(obj) {\n            var el;\n            if (typeof obj === \"string\") {\n                el = document.getElementById(obj);\n            }\n            else {\n                el = obj;\n            }\n            return el ? orchestrator.tree.getNodeByElement(el) : null;\n        }\n        html.getLayoutNode = getLayoutNode;\n        function dumpLayoutTree(root, indent) {\n            var s = \"\";\n            if (!indent) {\n                s += \"\\n\";\n                indent = \"\";\n            }\n            var ctor = root.constructor;\n            s += indent + ctor.name.toString() + \"\\n\";\n            for (var walker = root.tree.walk(); walker.step();) {\n                s += dumpLayoutTree(walker.current, indent + \"  \");\n            }\n            return s;\n        }\n        html.dumpLayoutTree = dumpLayoutTree;\n        function enableLogging() {\n            mirage.logger = mirage.logging.NewConsoleLogger(function (node) {\n                var el = orchestrator.tree.getElementByNode(node);\n                var id = el && el.id ? \"#\" + el.id : \"\";\n                var type = node.constructor;\n                return \"\" + type.name + id;\n            });\n        }\n        html.enableLogging = enableLogging;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        var dummy;\n        var HtmlNode = (function (_super) {\n            __extends(HtmlNode, _super);\n            function HtmlNode() {\n                _super.apply(this, arguments);\n            }\n            HtmlNode.getElement = function (node) {\n                return node.getAttached(\"html-element\");\n            };\n            HtmlNode.setElement = function (node, el) {\n                node.setAttached(\"html-element\", el);\n                node.invalidateMeasure();\n            };\n            HtmlNode.prototype.measureOverride = function (constraint) {\n                var el = HtmlNode.getElement(this);\n                return el ? calcElementDesired(el, constraint) : new mirage.Size();\n            };\n            HtmlNode.prototype.arrangeOverride = function (arrangeSize) {\n                return arrangeSize;\n            };\n            HtmlNode.isDummyElement = function (el) {\n                return el === dummy;\n            };\n            return HtmlNode;\n        })(mirage.core.LayoutNode);\n        html.HtmlNode = HtmlNode;\n        mirage.registerNodeType(\"html\", HtmlNode);\n        function calcElementDesired(el, constraint) {\n            if (!dummy) {\n                dummy = document.createElement('div');\n                dummy.id = \"mirage-dummy\";\n                dummy.style.position = \"absolute\";\n                dummy.style.boxSizing = \"border-box\";\n                dummy.style.display = \"none\";\n                document.body.appendChild(dummy);\n            }\n            dummy.style.width = isFinite(constraint.width) ? constraint.width + \"px\" : \"\";\n            dummy.style.height = isFinite(constraint.height) ? constraint.height + \"px\" : \"\";\n            dummy.style.display = \"\";\n            dummy.innerHTML = el.outerHTML;\n            var clone = dummy.firstElementChild;\n            clone.style.display = \"\";\n            var bounds = clone.getBoundingClientRect();\n            dummy.innerHTML = \"\";\n            dummy.style.display = \"none\";\n            return new mirage.Size(bounds.width, bounds.height);\n        }\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewOrchestrator(target) {\n            var tree = html.NewTreeTracker();\n            var binders = [];\n            var registry = html.NewBinderRegistry(tree, binders);\n            var sync = html.NewTreeSynchronizer(target, tree, registry);\n            var clock = html.NewAnimClock(onFrame);\n            function onFrame(now, delta) {\n                for (var i = 0; i < binders.length; i++) {\n                    binders[i].run();\n                }\n            }\n            return {\n                tree: tree,\n                binders: binders,\n                registry: registry,\n                sync: sync,\n                start: function () {\n                    sync.start(true);\n                    clock.enable();\n                },\n                stop: function () {\n                    clock.disable();\n                    sync.stop();\n                },\n            };\n        }\n        html.NewOrchestrator = NewOrchestrator;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewPanelInserter() {\n            var items = [];\n            return {\n                add: function (panel, el, node) {\n                    var item = panel.getAttached(\"html-sync-escrow\");\n                    if (!item) {\n                        item = {\n                            panel: panel,\n                            entries: [],\n                        };\n                        panel.setAttached(\"html-sync-escrow\", item);\n                        items.push(item);\n                    }\n                    item.entries.push({\n                        node: node,\n                        index: Array.prototype.indexOf.call(el.parentElement.children, el),\n                    });\n                },\n                commit: function () {\n                    for (var i = 0; i < items.length; i++) {\n                        var item = items[i];\n                        var panel = item.panel;\n                        var entries = item.entries;\n                        panel.setAttached(\"html-sync-escrow\", undefined);\n                        entries.sort(function (a, b) { return a.index - b.index; });\n                        var inserted = [];\n                        for (var j = 0; j < entries.length; j++) {\n                            var entry = entries[j];\n                            if (inserted.indexOf(entry.node) > -1)\n                                continue;\n                            inserted.push(entry.node);\n                            panel.insertChild(entry.node, entry.index);\n                        }\n                    }\n                },\n            };\n        }\n        html.NewPanelInserter = NewPanelInserter;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        function NewTreeSynchronizer(target, tree, registry, translator) {\n            tree = tree || html.NewTreeTracker();\n            registry = registry || html.NewBinderRegistry(tree);\n            translator = translator || html.NewElementTranslator();\n            function mirrorAdded(added) {\n                for (var i = 0; i < added.length; i++) {\n                    register(added[i]);\n                }\n            }\n            function mirrorUntagged(untagged, addedRoots, destroyedRoots) {\n                for (var i = 0; i < untagged.length; i++) {\n                    deregister(untagged[i], true, addedRoots, destroyedRoots);\n                }\n            }\n            function mirrorRemoved(removed, addedRoots, destroyedRoots) {\n                for (var i = 0; i < removed.length; i++) {\n                    deregister(removed[i], false, addedRoots, destroyedRoots);\n                }\n            }\n            function register(el) {\n                if (tree.elementExists(el) || !html.isMirageElement(el))\n                    return;\n                var node = translator.translateNew(el);\n                if (!node) {\n                    return;\n                }\n                tree.add(el, node);\n                for (var cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                    register(cur);\n                }\n            }\n            function deregister(el, isUntagged, addedRoots, destroyedRoots) {\n                var node = tree.removeElement(el);\n                if (!node)\n                    return;\n                if (!isUntagged) {\n                    for (var cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                        deregister(cur, true, null, null);\n                    }\n                }\n                else {\n                    for (var walker = node.tree.walk(); walker.step();) {\n                        walker.current.setParent(null);\n                    }\n                }\n                var parentNode = node.tree.parent;\n                if (!parentNode) {\n                    destroyedRoots.push(node);\n                    promoteChildren(el, addedRoots);\n                }\n                if (parentNode instanceof mirage.Panel) {\n                    parentNode.removeChild(node);\n                }\n                else {\n                    node.setParent(null);\n                }\n            }\n            function promoteChildren(el, addedRoots) {\n                for (var cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                    if (html.isMirageElement(cur)) {\n                        addedRoots.push(tree.getNodeByElement(cur));\n                    }\n                    else {\n                        promoteChildren(cur, addedRoots);\n                    }\n                }\n            }\n            function mirrorTranslations(changes, addedRoots, destroyedRoots) {\n                for (var i = 0; i < changes.length; i++) {\n                    var change = changes[i];\n                    var node = tree.getNodeByElement(change.target);\n                    var result = translator.translateChange(change.target, node, change.oldValue);\n                    if (result !== node) {\n                        replaceNode(node, result, addedRoots, destroyedRoots);\n                    }\n                    else if (!result) {\n                        deregister(change.target, true, addedRoots, destroyedRoots);\n                    }\n                }\n            }\n            function replaceNode(oldNode, newNode, addedRoots, destroyedRoots) {\n                var uid = tree.replaceNode(oldNode, newNode);\n                if (!uid)\n                    return;\n                var parentNode = oldNode.tree.parent;\n                if (parentNode instanceof mirage.Panel) {\n                    var index = parentNode.indexOfChild(oldNode);\n                    parentNode.removeChild(oldNode);\n                    parentNode.insertChild(newNode, index);\n                }\n                else if (!parentNode) {\n                    destroyedRoots.push(oldNode);\n                    addedRoots.push(newNode);\n                }\n                else {\n                    oldNode.setParent(null);\n                    newNode.setParent(parentNode);\n                }\n                if (newNode instanceof mirage.Panel) {\n                    for (var walker = oldNode.tree.walk(); walker.step();) {\n                        newNode.appendChild(walker.current);\n                    }\n                    if (oldNode instanceof mirage.Panel)\n                        oldNode.tree.children.length = 0;\n                }\n            }\n            function mirrorAncestry(added, addedRoots, inserter) {\n                for (var i = 0; i < added.length; i++) {\n                    var el = added[i];\n                    var node = tree.getNodeByElement(el);\n                    if (!node)\n                        continue;\n                    var parentNode = (el.parentElement ? tree.getNodeByElement(el.parentElement) : null) || null;\n                    if (parentNode instanceof mirage.Panel) {\n                        inserter.add(parentNode, el, node);\n                    }\n                    else {\n                        node.setParent(parentNode);\n                    }\n                    if (!node.tree.parent) {\n                        addedRoots.push(node);\n                    }\n                    configAncestors(el, node, inserter);\n                }\n            }\n            function configAncestors(parentEl, parentNode, inserter) {\n                for (var cur = parentEl.firstElementChild, i = 0; !!cur; cur = cur.nextElementSibling, i++) {\n                    var curNode = tree.getNodeByElement(cur);\n                    if (curNode && !curNode.tree.parent) {\n                        if (parentNode instanceof mirage.Panel) {\n                            inserter.add(parentNode, cur, curNode);\n                        }\n                        else {\n                            curNode.setParent(parentNode);\n                        }\n                        configAncestors(cur, curNode, inserter);\n                    }\n                }\n            }\n            function update(added, removed, untagged, changed) {\n                var inserter = html.NewPanelInserter();\n                var addedRoots = [];\n                var destroyedRoots = [];\n                mirrorAdded(added);\n                mirrorUntagged(untagged, addedRoots, destroyedRoots);\n                mirrorRemoved(removed, addedRoots, destroyedRoots);\n                mirrorTranslations(changed, addedRoots, destroyedRoots);\n                mirrorAncestry(added, addedRoots, inserter);\n                inserter.commit();\n                registry.update(addedRoots, destroyedRoots);\n            }\n            function init() {\n                var added = [];\n                scan(target, added, false);\n                update(added, [], [], []);\n            }\n            function scan(el, added, parentIsMirage) {\n                var isMirage = html.isMirageElement(el);\n                if (isMirage && !parentIsMirage)\n                    added.push(el);\n                for (var cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                    scan(cur, added, isMirage);\n                }\n            }\n            var monitor = html.NewDOMMonitor(target, update);\n            return {\n                start: function (initialize) {\n                    if (initialize)\n                        init();\n                    monitor.start();\n                },\n                stop: function () {\n                    monitor.stop();\n                },\n            };\n        }\n        html.NewTreeSynchronizer = NewTreeSynchronizer;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\nvar mirage;\n(function (mirage) {\n    var html;\n    (function (html) {\n        var XMLNS = \"http://schemas.wsick.com/mirage/html\";\n        function NewTreeTracker() {\n            var elements = {};\n            var nodes = {};\n            var lastUid = 0;\n            return {\n                add: function (el, node) {\n                    lastUid++;\n                    var uid = lastUid.toString();\n                    el.setAttributeNS(XMLNS, \"uid\", uid);\n                    node.setAttached(\"mirage-uid\", uid);\n                    elements[uid] = el;\n                    nodes[uid] = node;\n                    return uid;\n                },\n                replaceNode: function (oldNode, newNode) {\n                    var uid = oldNode.getAttached(\"mirage-uid\");\n                    if (nodes[uid] === oldNode) {\n                        oldNode.setAttached(\"mirage-uid\", undefined);\n                        newNode.setAttached(\"mirage-uid\", uid);\n                        nodes[uid] = newNode;\n                        return uid;\n                    }\n                    return \"\";\n                },\n                removeElement: function (el) {\n                    var uid = el.getAttributeNS(XMLNS, \"uid\");\n                    var node = !uid ? null : nodes[uid];\n                    el.removeAttributeNS(XMLNS, \"uid\");\n                    if (node) {\n                        node.setAttached(\"mirage-uid\", undefined);\n                        delete elements[uid];\n                        delete nodes[uid];\n                    }\n                    return node;\n                },\n                elementExists: function (el) {\n                    var uid = el.getAttributeNS(XMLNS, \"uid\");\n                    return elements[uid] === el;\n                },\n                getNodeByElement: function (el) {\n                    var uid = el.getAttributeNS(XMLNS, \"uid\");\n                    return nodes[uid];\n                },\n                getElementByNode: function (node) {\n                    var uid = node.getAttached(\"mirage-uid\");\n                    return elements[uid];\n                },\n            };\n        }\n        html.NewTreeTracker = NewTreeTracker;\n        function getNodeUid(node) {\n            return node.getAttached(\"mirage-uid\");\n        }\n        html.getNodeUid = getNodeUid;\n    })(html = mirage.html || (mirage.html = {}));\n})(mirage || (mirage = {}));\n","namespace mirage.html {\n    let dummy: HTMLElement;\n\n    export class HtmlNode extends core.LayoutNode {\n        static getElement(node: core.LayoutNode): HTMLElement {\n            return node.getAttached(\"html-element\");\n        }\n\n        static setElement(node: core.LayoutNode, el: HTMLElement) {\n            node.setAttached(\"html-element\", el);\n            node.invalidateMeasure();\n        }\n\n        protected measureOverride(constraint: ISize): ISize {\n            let el = HtmlNode.getElement(this);\n            return el ? calcElementDesired(el, constraint) : new Size();\n        }\n\n        protected arrangeOverride(arrangeSize: ISize): ISize {\n            return arrangeSize;\n        }\n\n        static isDummyElement(el: Node): boolean {\n            return el === dummy;\n        }\n    }\n    registerNodeType(\"html\", HtmlNode);\n\n    function calcElementDesired(el: HTMLElement, constraint: ISize): ISize {\n        if (!dummy) {\n            dummy = document.createElement('div');\n            dummy.id = \"mirage-dummy\";\n            dummy.style.position = \"absolute\";\n            dummy.style.boxSizing = \"border-box\";\n            dummy.style.display = \"none\";\n            document.body.appendChild(dummy);\n        }\n\n        dummy.style.width = isFinite(constraint.width) ? `${constraint.width}px` : \"\";\n        dummy.style.height = isFinite(constraint.height) ? `${constraint.height}px` : \"\";\n        dummy.style.display = \"\";\n\n        dummy.innerHTML = el.outerHTML;\n        let clone = <HTMLElement>dummy.firstElementChild;\n        clone.style.display = \"\";\n        let bounds = clone.getBoundingClientRect();\n        dummy.innerHTML = \"\";\n\n        dummy.style.display = \"none\";\n\n        return new Size(bounds.width, bounds.height);\n    }\n}","namespace mirage.html {\n    export interface IOrchestrator {\n        tree: ITreeTracker;\n        binders: IBinder[];\n        registry: IBinderRegistry;\n        sync: ITreeSynchronizer;\n        start();\n        stop();\n    }\n\n    export function NewOrchestrator(target: Node): IOrchestrator {\n        let tree = NewTreeTracker();\n        let binders: IBinder[] = [];\n        let registry = NewBinderRegistry(tree, binders);\n        let sync = NewTreeSynchronizer(target, tree, registry);\n        let clock = NewAnimClock(onFrame);\n\n        function onFrame(now: number, delta: number) {\n            for (let i = 0; i < binders.length; i++) {\n                binders[i].run();\n            }\n        }\n\n        return {\n            tree: tree,\n            binders: binders,\n            registry: registry,\n            sync: sync,\n            start() {\n                sync.start(true);\n                clock.enable();\n            },\n            stop() {\n                clock.disable();\n                sync.stop();\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     When running tree synchronization, child nodes can appear out of order\n     The Panel Inserter will track items in escrow\n     When ready to commit, each item will be inserted into the proper index\n     */\n\n    export interface IPanelInserter {\n        add(panel: Panel, el: Element, node: core.LayoutNode);\n        commit();\n    }\n\n    interface IPanelInsertItem {\n        panel: Panel;\n        entries: IPanelInsertItemEntry[];\n    }\n    interface IPanelInsertItemEntry {\n        node: core.LayoutNode;\n        index: number;\n    }\n\n    export function NewPanelInserter(): IPanelInserter {\n        var items: IPanelInsertItem[] = [];\n\n        return {\n            add(panel: Panel, el: Element, node: core.LayoutNode) {\n                let item = panel.getAttached(\"html-sync-escrow\");\n                if (!item) {\n                    item = {\n                        panel: panel,\n                        entries: [],\n                    };\n                    panel.setAttached(\"html-sync-escrow\", item);\n                    items.push(item);\n                }\n\n                item.entries.push({\n                    node: node,\n                    index: Array.prototype.indexOf.call(el.parentElement.children, el),\n                });\n            },\n            commit() {\n                for (var i = 0; i < items.length; i++) {\n                    let item = items[i];\n                    let panel = item.panel;\n                    let entries = item.entries;\n                    panel.setAttached(\"html-sync-escrow\", undefined);\n                    entries.sort((a, b) => a.index - b.index);\n                    let inserted: core.LayoutNode[] = [];\n                    for (var j = 0; j < entries.length; j++) {\n                        let entry = entries[j];\n                        // deduplicate entries\n                        if (inserted.indexOf(entry.node) > -1)\n                            continue;\n                        inserted.push(entry.node);\n                        panel.insertChild(entry.node, entry.index);\n                    }\n                }\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Tree Synchronizer tracks added/removed DOM elements.\n     It is responsible for synchronizing the render tree with the layout tree.\n     It also detects mirage roots and builds binders.\n     */\n\n    export interface ITreeSynchronizer {\n        start(initialize: boolean);\n        stop();\n    }\n\n    export function NewTreeSynchronizer(target: Node, tree?: ITreeTracker, registry?: IBinderRegistry, translator?: IElementTranslator): ITreeSynchronizer {\n        tree = tree || NewTreeTracker();\n        registry = registry || NewBinderRegistry(tree);\n        translator = translator || NewElementTranslator();\n\n        function mirrorAdded(added: Element[]) {\n            // Mirror new render elements to layout tree\n            for (var i = 0; i < added.length; i++) {\n                register(added[i]);\n            }\n        }\n\n        function mirrorUntagged(untagged: Element[], addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            // Mirror nodes that have been untagged, but remain in DOM\n            for (var i = 0; i < untagged.length; i++) {\n                deregister(untagged[i], true, addedRoots, destroyedRoots);\n            }\n        }\n\n        function mirrorRemoved(removed: Element[], addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            // Mirror old render elements from layout tree\n            // Adds nodes to addedRoots that were orphaned by destroying a root\n            // Adds nodes to destroyedRoots that were destroyed mirage parents\n            for (var i = 0; i < removed.length; i++) {\n                deregister(removed[i], false, addedRoots, destroyedRoots);\n            }\n        }\n\n        function register(el: Element) {\n            if (tree.elementExists(el) || !isMirageElement(el))\n                return;\n            // The parent may not be mirrored in the layout tree yet\n            // We will set parent after all adds/removes have completed\n            let node = translator.translateNew(el);\n            if (!node) {\n                // we could not detect node, it will not be created\n                return;\n            }\n            tree.add(el, node);\n\n            // register children\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                register(cur);\n            }\n        }\n\n        function deregister(el: Element, isUntagged: boolean, addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            let node = tree.removeElement(el);\n            if (!node)\n                return;\n            if (!isUntagged) {\n                // deregister children\n                for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                    deregister(cur, true, null, null);\n                }\n            } else {\n                // drop 'parent' from children\n                for (let walker = node.tree.walk(); walker.step();) {\n                    walker.current.setParent(null);\n                }\n            }\n\n            let parentNode = node.tree.parent;\n            if (!parentNode) {\n                destroyedRoots.push(node);\n                promoteChildren(el, addedRoots);\n            }\n\n            if (parentNode instanceof Panel) {\n                parentNode.removeChild(node);\n            } else {\n                node.setParent(null);\n            }\n        }\n\n        function promoteChildren(el: Element, addedRoots: core.LayoutNode[]) {\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                if (isMirageElement(cur)) {\n                    addedRoots.push(tree.getNodeByElement(cur));\n                } else {\n                    promoteChildren(cur, addedRoots);\n                }\n            }\n        }\n\n        function mirrorTranslations(changes: IDataLayoutChange[], addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            for (let i = 0; i < changes.length; i++) {\n                let change = changes[i];\n                let node = tree.getNodeByElement(change.target);\n                let result = translator.translateChange(change.target, node, change.oldValue);\n                if (result !== node) {\n                    // destroy old node, rehook parent/children to new node\n                    replaceNode(node, result, addedRoots, destroyedRoots);\n                } else if (!result) {\n                    // destroy this node, deregister will also hoist children properly\n                    deregister(change.target, true, addedRoots, destroyedRoots);\n                }\n            }\n        }\n\n        function replaceNode(oldNode: core.LayoutNode, newNode: core.LayoutNode, addedRoots: core.LayoutNode[], destroyedRoots: core.LayoutNode[]) {\n            let uid = tree.replaceNode(oldNode, newNode);\n            if (!uid) // old node does not exist, what should we do?\n                return;\n\n            // Adjust parent's children\n            let parentNode = oldNode.tree.parent;\n            if (parentNode instanceof Panel) {\n                let index = parentNode.indexOfChild(oldNode);\n                parentNode.removeChild(oldNode);\n                parentNode.insertChild(newNode, index);\n            } else if (!parentNode) {\n                destroyedRoots.push(oldNode);\n                addedRoots.push(newNode);\n            } else {\n                oldNode.setParent(null);\n                newNode.setParent(parentNode);\n            }\n\n            // Migrate old children to new node\n            if (newNode instanceof Panel) {\n                for (let walker = oldNode.tree.walk(); walker.step();) {\n                    newNode.appendChild(walker.current);\n                }\n                if (oldNode instanceof Panel)\n                    oldNode.tree.children.length = 0;\n            }\n        }\n\n        function mirrorAncestry(added: Element[], addedRoots: core.LayoutNode[], inserter: IPanelInserter) {\n            // Configure parents after all layout nodes have been created/destroyed\n            // This is done to ensure parent layout nodes exist\n            // Adds nodes to addedRoots that do not have mirage parents\n            for (var i = 0; i < added.length; i++) {\n                let el = added[i];\n                let node = tree.getNodeByElement(el);\n                if (!node)\n                    continue;\n                // coerce 'none' to null\n                let parentNode = (el.parentElement ? tree.getNodeByElement(el.parentElement) : null) || null;\n                if (parentNode instanceof Panel) {\n                    // To ensure proper ordering, we will collect all new children for each parent\n                    // We will insert the children in sorted order\n                    inserter.add(parentNode, el, node);\n                } else {\n                    node.setParent(parentNode);\n                }\n                if (!node.tree.parent) {\n                    addedRoots.push(node);\n                }\n                configAncestors(el, node, inserter);\n            }\n        }\n\n        function configAncestors(parentEl: Element, parentNode: core.LayoutNode, inserter: IPanelInserter) {\n            for (let cur = parentEl.firstElementChild, i = 0; !!cur; cur = cur.nextElementSibling, i++) {\n                let curNode = tree.getNodeByElement(cur);\n                if (curNode && !curNode.tree.parent) {\n                    if (parentNode instanceof Panel) {\n                        inserter.add(parentNode, cur, curNode);\n                    } else {\n                        curNode.setParent(parentNode);\n                    }\n                    configAncestors(cur, curNode, inserter);\n                }\n            }\n        }\n\n        /*\n         Each update, we need to\n         - construct new layout nodes mirroring new render elements\n         - detach layout nodes mirroring old render elements\n         - run data-layout translation changes\n         - configure all new layout nodes with parent\n         - hoist binders to the true root\n         - add binders for new root nodes\n         */\n        function update(added: Element[], removed: Element[], untagged: Element[], changed: IDataLayoutChange[]) {\n            let inserter = NewPanelInserter();\n            let addedRoots: core.LayoutNode[] = [];\n            let destroyedRoots: core.LayoutNode[] = [];\n\n            mirrorAdded(added);\n            mirrorUntagged(untagged, addedRoots, destroyedRoots);\n            mirrorRemoved(removed, addedRoots, destroyedRoots);\n            mirrorTranslations(changed, addedRoots, destroyedRoots);\n            mirrorAncestry(added, addedRoots, inserter);\n\n            inserter.commit();\n            registry.update(addedRoots, destroyedRoots);\n        }\n\n        function init() {\n            let added: Element[] = [];\n            scan(<Element>target, added, false);\n            update(added, [], [], []);\n        }\n\n        function scan(el: Element, added: Element[], parentIsMirage: boolean) {\n            let isMirage = isMirageElement(el);\n            if (isMirage && !parentIsMirage)\n                added.push(el);\n            for (let cur = el.firstElementChild; !!cur; cur = cur.nextElementSibling) {\n                scan(cur, added, isMirage);\n            }\n        }\n\n        var monitor = NewDOMMonitor(target, update);\n        return {\n            start(initialize: boolean) {\n                if (initialize)\n                    init();\n                monitor.start();\n            },\n            stop() {\n                monitor.stop();\n            },\n        };\n    }\n}","namespace mirage.html {\n    /*\n     The Tree Tracker tracks render elements (DOM) and layout nodes (mirage).\n     This is a singleton and tracks the entire DOM.\n     Instead of doing lookups using a synchronized double-array, we are tracking a uid on each object.\n     The render element and layout node can be retrieved by uid.\n     We use a DOM attribute ('http://schemas.wsick.com/mirage/html':uid)\n     and a layout node attached property ('mirage-uid') to track the uid.\n     This uid is a running int counter that is converted to a string to match attributes.\n     */\n\n    var XMLNS = \"http://schemas.wsick.com/mirage/html\";\n\n    export interface ITreeTracker {\n        add(el: Element, node: core.LayoutNode): string;\n        replaceNode(oldNode: core.LayoutNode, newNode: core.LayoutNode): string;\n        removeElement(el: Element): core.LayoutNode;\n        elementExists(el: Element): boolean;\n        getNodeByElement(el: Element): core.LayoutNode;\n        getElementByNode(node: core.LayoutNode): Element;\n    }\n\n    interface IElementHash {\n        [uid: string]: Element;\n    }\n    interface ILayoutNodeHash {\n        [uid: string]: core.LayoutNode;\n    }\n\n    export function NewTreeTracker(): ITreeTracker {\n        var elements: IElementHash = {};\n        var nodes: ILayoutNodeHash = {};\n        var lastUid = 0;\n\n        return {\n            add(el: Element, node: core.LayoutNode): string {\n                lastUid++;\n                var uid = lastUid.toString();\n                el.setAttributeNS(XMLNS, \"uid\", uid);\n                node.setAttached(\"mirage-uid\", uid);\n                elements[uid] = el;\n                nodes[uid] = node;\n                return uid;\n            },\n            replaceNode(oldNode: core.LayoutNode, newNode: core.LayoutNode): string {\n                let uid = oldNode.getAttached(\"mirage-uid\");\n                if (nodes[uid] === oldNode) {\n                    oldNode.setAttached(\"mirage-uid\", undefined);\n                    newNode.setAttached(\"mirage-uid\", uid);\n                    nodes[uid] = newNode;\n                    return uid;\n                }\n                return \"\";\n            },\n            removeElement(el: Element): core.LayoutNode {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                var node = !uid ? null : nodes[uid];\n                el.removeAttributeNS(XMLNS, \"uid\");\n                if (node) {\n                    node.setAttached(\"mirage-uid\", undefined);\n                    delete elements[uid];\n                    delete nodes[uid];\n                }\n                return node;\n            },\n            elementExists(el: Element): boolean {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                return elements[uid] === el;\n            },\n            getNodeByElement(el: Element): core.LayoutNode {\n                var uid = el.getAttributeNS(XMLNS, \"uid\");\n                return nodes[uid];\n            },\n            getElementByNode(node: core.LayoutNode): Element {\n                var uid = node.getAttached(\"mirage-uid\");\n                return elements[uid];\n            },\n        };\n    }\n\n    export function getNodeUid(node: core.LayoutNode): string {\n        return node.getAttached(\"mirage-uid\");\n    }\n}"],"sourceRoot":"/mirage-html/"}